package main

import (
	"fmt"
	"sync"
	"time"
)

// *был некоторый начальный код*
// ЗАДАНИЕ:
// Сделать код хорошим.
// Приложение эмулирует получение и обработку заданий, пытается и получать, и обрабатывать в конкурентном режиме.
// В выводе должны быть успешные задачи и ошибки выполнения остальных.


// Настоятельно рекомендуется прежде всего ознакомиться с кодом, не с текстом ниже. 
// Для простоты принятия решения по качеству кода рекомендуется удалить все комментарии - 
//   идеально хороший код должен быть понятен без любых комментариев (кроме контрактов). 
// Но: "лучшее - враг хорошего".

// РЕШЕНИЕ:
// * Комментарии на языке, принятом в команде рабочим - для уменьшения когнитивной нагрузки при чтении и понимании кода;
// * Комментарии на одном языке;
// * При разных языках (человеческих) в команде, комментарии должны быть понимаемыми не сложнее кода на языке (человеческом), который проще освоить из используемых;
// * Самодокументированный код - меньше переделок, проще код [нужно писать];
// * Именование переменных, функций и типов имеет унифицированные форматы - 
//     для исключения необходимости смотреть на определение для понимания что происходит, 
//       меньше нагрузка на оперативную память (человека) и привычки, больше нагрузка на категоризацию и скорость мышления;
// * Почти каждую функцию должно быть можно использовать в любом другом месте - минимум сторонних эффектов и неявных зависимостей;
// * По ходу чтения кода не должно возникать вопроса "зачем/почему тут это?";
// * Использование переменных должно быть, по-хорошему, в пределах одного экрана;
// * Статусы обозначаются кодом (int/const), не строками - 
//     локализация (язык), локальность логики (обработка по требованию, не заранее; обработка единым механизмом),
//     необходимость сравнения через одни и те же переменные, не по значению/магическим числам - 
//       расширяемость, поддерживаемость + уменьшение когнитивной нагрузки + меньше hardcode,
//     сравнение чисел эффективнее сравнения строк - проще обрабатывать/использовать;
// * Одна сущность - одна задача, задача в названии сущности;
// * Переменные создавать перед использованием - не забивать оперативную память человека
//
// * Нельзя терять данные;
// * Разноуровневая локальность должна быть документирована в контракте;
// * Создавать новые данные максимально поздно насколько _возможно_ - не засорять память, 
//     + локализация (язык), расширяемость, поддерживаемость, эффективность, локальность логики;
// * Объект типа - субъект своих данных и единственный, кто содержит ответственность за это, как это устроено внутри не должно волновать окружение;
// * При ошибке должно быть понятно что и где произошло - для успешного моделирования причин ошибок и их устранения/недопущения;
// * Код должен быть тестируемым: любой объект должен мочь находиться в любом контексте (в т.ч. искусственном), 
//     промежуточные состояния не должны быть слишком разными - чтобы можно было проверить действие методов, 
//     методы должны выполнять одну задачу (проверяемую);
// * Mockable алгоритмы: любая часть программы должна быть такой, 
//     что замена её на другую, строго контролируемую, логику (с тем же контрактом) не должна создавать дополнительных проблем - должна быть "безболезненной";
// * Нулевой/не определённый объект/поле - тоже состояние, нельзя игнорировать это в бизнес-логике.
//   
//   Продолжение следует...

const (
	taskStatus_Undefinded = 0
	taskStatus_Complete = 1
	taskStatus_Failed = 2
	taskStatus_Canceled = 3 // резерв, например
)

type Task_t struct {
	id int
	start_time time.Time // время создания
	last_action time.Time // время выполнения
	result int
	result_comment string
}

func main() {
	// Генерирут задачи, некоторые ошибочные
	// "здоровые" задачи выполняются; все задачи пересылаются на сортировку
	// сортировка пишет в разные каналы для вывода
	// в конце, после завершения всех действий, вывод всех списков результатов

	task_source_ch := make(chan Task_t, 10)
	end_ch := make(chan bool)

	go taskCreating(task_source_ch, end_ch)

	// Выводы разных типов для одинаковых входов - решается требованиями, это не чисто архитектурный вопрос;
	// в данном случае использование похожее (вывод в консоль), в реальных задачах использование может быть по отличающимся алгоритмам
	done_tasks_ch := make(chan Task_t)
	undone_tasks_ch := make(chan error)

	// Можно вынести в отдельную функцию для тестируемости, 
	//   но: для простого кода отдельная функция со строгим контрактом (а тут нужен) - (возможное) увеличение когнитивной нагрузки на память и поиск,
	//   нагрузки на поддержку, усложнение восприятия целостности кода.
	// + У "простого" кода есть гарантия от производителя компилятора - 
	//     чем более идиоматичный, "правильный" и короткий код, тем меньше шанс ошибки - отдельно тестировать необязательно.
	// + Придумывать названия функциям, придумывать/проектировать интерфейс - это дополнительная когнитивная нагрузка + занимает пространство имён.
	// В общем, нужно соблюдать баланс.
	go func() {
		defer close(done_tasks_ch)
		defer close(undone_tasks_ch)
		
		for task := range task_source_ch {
			task_done := doTaskJob(task)
			taskSort(task_done, done_tasks_ch, undone_tasks_ch)
		}
	}() 

	wg_sort := &sync.WaitGroup{}
	result := map[int]Task_t{}
	err := []error{}
	
	// Для этих двух горутин всё та же история про вынос отдельно, что и выше.
	wg_sort.Add(1)
	go func() {
		defer wg_sort.Done()
		
		for r := range done_tasks_ch {
			result[r.id] = r
		}
	}()
	wg_sort.Add(1)
	go func() {
		defer wg_sort.Done()

		for r := range undone_tasks_ch {
			err = append(err, r)
		}
	}()

	time.Sleep(time.Second * 3)
	
	close(end_ch)
	wg_sort.Wait()

	println("Errors:")
	for idx, task := range err {
		println(idx, task.Error())
	}

	println("Done tasks:")
	for _, task := range result {
		println(task.String())
	}
}

// Не создаёт горутин, функция, содержит бесконечный цикл;
// Генерирует задачи в канал;
//
// Заканчивает при получении сигнала из второго канала;
// В конце закрывает канал записи.
func taskCreating(sink_ch chan<- Task_t, end_ch <-chan bool) {
	for {
		now := time.Now()
		t := Task_t{id: int(time.Now().Unix()), start_time: now}
		if time.Now().Nanosecond()%2 > 0 { // условие появления ошибочных заданий
			t.Fail("Some error occured")
		}
		sink_ch <- t
		select {
			case <-end_ch:
				close(sink_ch)
				return
			default: // для неблокирующей генерации задач, тело пустое по задумке
		}
	}
}

func doTaskJob(task Task_t) Task_t {
	if task.Processed() {
		return task
	}
	if task.start_time.After(time.Now().Add(-20 * time.Second)) {
		task.Success("task has been successed")
	} else {
		task.Fail("something went wrong")
	}

	time.Sleep(time.Millisecond * 150)

	return task
}

func taskSort(task Task_t, done_tasks_ch chan<- Task_t, undone_tasks_ch chan<- error){
	if task.Complete() {
		done_tasks_ch <- task
	} else {
		undone_tasks_ch <- fmt.Errorf("err: %s", task.String())
	}
}

func (t *Task_t) Success(comment string) {
	t.last_action = time.Now()
	t.result = taskStatus_Complete
	t.result_comment = comment
}

func (t *Task_t) Fail(comment string) {
	t.last_action = time.Now()
	t.result = taskStatus_Failed
	t.result_comment = comment
}

func (t Task_t) Complete() bool {
	return t.result==taskStatus_Complete
}

func (t Task_t) Processed() bool {
	return t.result!=taskStatus_Undefinded
}

func (t Task_t) resultStr() string {
	switch t.result {
		case taskStatus_Complete:
			return "Complete"
		case taskStatus_Failed:
			return "Failed"
		case taskStatus_Canceled:
			return "Canceled"
		default:
			return "undefined"
	}
}

func (t Task_t) String() string {
	la := t.last_action
	if la.IsZero() {
		la = t.start_time
	}
	return fmt.Sprintf("Task:{id:%v, start_time:%v, last_action: %v, result:\"%s\", comment: \"%s\"}", 
		t.id, t.start_time.UnixMicro(), la.UnixMicro(), t.resultStr(), t.result_comment)
}